package pattern

import "fmt"

/*
	Реализовать паттерн «стратегия».
Объяснить применимость паттерна, его плюсы и минусы, а также реальные примеры использования данного примера на практике.
	https://en.wikipedia.org/wiki/Strategy_pattern
*/

// Strategy определяет интерфейс стратегии
type Strategy interface {
	Execute(a, b int) int
}

// AddStrategy конкретная стратегия сложения
type AddStrategy struct{}

func (s *AddStrategy) Execute(a, b int) int {
	return a + b
}

// MultiplyStrategy конкретная стратегия умножения
type MultiplyStrategy struct{}

func (s *MultiplyStrategy) Execute(a, b int) int {
	return a * b
}

// Context обеспечивает контекст для выполнения стратегии
type Context struct {
	strategy Strategy
}

func (c *Context) SetStrategy(strategy Strategy) {
	c.strategy = strategy
}

func (c *Context) ExecuteStrategy(a, b int) int {
	return c.strategy.Execute(a, b)
}

// Пример использования паттерна "Стратегия"
func main() {
	context := &Context{}

	// Используем стратегию сложения
	context.SetStrategy(&AddStrategy{})
	fmt.Println("Add Strategy Result:", context.ExecuteStrategy(3, 4))

	// Используем стратегию умножения
	context.SetStrategy(&MultiplyStrategy{})
	fmt.Println("Multiply Strategy Result:", context.ExecuteStrategy(3, 4))
}

//Применимость паттерна «Стратегия»:
//
//Когда есть несколько родственных классов, которые отличаются только поведением.
//Когда вам нужно иметь несколько различных вариантов одного и того же алгоритма.
//Когда класс, содержащий данные, не должен знать, какие алгоритмы будут на них применяться.
//Когда класс содержит много условных операторов, выбирающих поведения на основе типа класса.
//Плюсы:
//
//Изоляция реализации алгоритма от кода, который его использует.
//Замена наследования делегированием.
//Реализует принцип открытости/закрытости.
//Минусы:
//
//Клиент должен знать о стратегиях, чтобы выбрать подходящую.
//Увеличивает общее количество объектов в приложении.
//Примеры использования на практике:
//
//Системы оплаты, которые поддерживают различные способы проведения платежа (кредитные карты, PayPal, криптовалюта).
//Приложения для картографических сервисов, где могут использоваться различные алгоритмы поиска пути (минимальное время, минимальное расстояние).
//Фреймворки для тестирования, где различные стратегии используются для запуска тестов (параллельный запуск, последовательный запуск, запуск по тегам).
