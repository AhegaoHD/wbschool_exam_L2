package pattern

import "fmt"

/*
	Реализовать паттерн «комманда».
Объяснить применимость паттерна, его плюсы и минусы, а также реальные примеры использования данного примера на практике.
	https://en.wikipedia.org/wiki/Command_pattern
*/

// Command интерфейс, представляющий команду
type Command interface {
	Execute()
}

// ConcreteCommand конкретная команда, реализующая Command
type ConcreteCommand struct {
	receiver *Receiver
}

// Execute выполняет команду (делегирует выполнение получателю)
func (c *ConcreteCommand) Execute() {
	c.receiver.Action()
}

// Receiver получатель и исполнитель команды
type Receiver struct {
	// Поля и методы, специфичные для Receiver
}

// Action специфическое действие, выполняемое Receiver
func (r *Receiver) Action() {
	fmt.Println("Receiver has performed an action")
}

// Invoker инициатор, хранит команду и вызывает её выполнение
type Invoker struct {
	command Command
}

// StoreCommand принимает команду для последующего выполнения
func (i *Invoker) StoreCommand(command Command) {
	i.command = command
}

// ExecuteCommand вызывает команду на выполнение
func (i *Invoker) ExecuteCommand() {
	i.command.Execute()
}

// Пример использования паттерна "Команда"
func main() {
	invoker := &Invoker{}
	receiver := &Receiver{}
	command := &ConcreteCommand{receiver}
	invoker.StoreCommand(command)
	invoker.ExecuteCommand()
}

//Применимость паттерна «Команда»:
//
//Когда необходимо параметризовать объекты выполняемым действием.
//Когда необходимо организовать очередь запросов, планировать их выполнение, либо выполнять операции отката.
//Когда нужно поддерживать логирование изменений, чтобы можно было отменять операции.

//Плюсы:
//
//Отделяет классы, инициирующие операции, от классов, которые выполняют эти операции.
//Упрощает расширение команд и добавление новых.
//Позволяет собирать сложные команды из простых.
//Поддерживает отмену и повтор операций.

//Минусы:
//
//Может привести к увеличению количества классов в приложении.
//Усложняет структуру кода из-за необходимости создания дополнительных классов.

//Примеры использования на практике:
//
//История команд в графических редакторах: команды для редактирования изображения инкапсулируются в объекты, которые можно отменять и повторять.
//Операции в базах данных: транзакции реализуются как команды, которые можно откатить, если операция не может быть завершена.
//Интеграция систем: задачи, которые нужно выполнить, инкапсулируются в команды, отправляемые по сети и выполняемые удаленно.
